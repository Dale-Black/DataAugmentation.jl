[{"body":"Quickstart Import the library: Load your data Create an item that contains the data you want to augment: Create a transform: Apply the transformation and unwrap the data:","id":"docs/quickstart.html#quickstart"},{"body":"private   MapElem   —   struct Applies  f  to every element in an  [ AbstractArrayItem ] .","id":"docstrings/DataAugmentation.MapElem.html"},{"body":"Gallery","id":"docs/imagetransforms.html#gallery"},{"body":"Examples","id":"docstrings/DataAugmentation.BoundingBox.html#examples"},{"body":"private   boundssize   —   function (100, 100) |> makebounds |> boundssize == (100, 100)","id":"docstrings/DataAugmentation.boundssize.html"},{"body":"private   ComposedAffine   —   struct Composes several affine transformations . Due to associativity of affine transformations, the transforms can be combined before applying, leading to large performance improvements . compose ing multiple  AbstractAffine s automatically creates a  ComposedAffine .","id":"docstrings/DataAugmentation.ComposedAffine.html"},{"body":"private   getaffine   —   function Return an affine transformation matrix, see CoordinateTransformations . jl . Takes into account the  bounds  of the item it is applied to as well as the  tfm ’ s  randstate .","id":"docstrings/DataAugmentation.getaffine.html"},{"body":"Examples","id":"docstrings/DataAugmentation.makebounds.html#examples"},{"body":"Interface An  AbstractAffine  transform  “ T ”  has to implement: getaffine (tfm::T, getbounds(item), getrandstate(tfm)) To be able to apply affine transformations an  Item  type  I  must implement: getbounds (item::MyItem)  returns the spatial bounds of an item, e . g .   size(img)  for an image array applyaffine(item::MyItem, A)::MyItem  applies transformation matrix  A (constructed with  getaffine ) to  item  and returns an item of the same type","id":"docstrings/DataAugmentation.AbstractAffine.html#interface"},{"body":"RandomResizeCrop (sz) Resizes the sides so that one of them is no longer than  sz  and crops a region of size  sz   from a random location .","id":"docs/imagetransforms.html#randomresizecropsz"},{"body":"public   CroppedAffine   —   struct Applies an affine  transform  and crops with  croptransform , such that  getbounds(apply(transform, item)) == getcrop(croptransform) This wrapper leads to performance improvements when warping an image, since only the indices within the bounds of  crop  need to be evaluated . compose ing any  AbstractAffine  with a  Crop constructs a  CroppedAffine .","id":"docstrings/DataAugmentation.CroppedAffine.html"},{"body":"public   BoundingBox   —   parametric type Item wrapper around  Keypoints .","id":"docstrings/DataAugmentation.BoundingBox.html"},{"body":"public   Identity   —   struct Does nothing .","id":"docstrings/DataAugmentation.Identity.html"},{"body":"private   getrandstate   —   function Random state to pass as keyword argument to  apply .  Useful for stochastic transforms .","id":"docstrings/DataAugmentation.getrandstate.html"},{"body":"public   apply   —   function Apply  tfm  to an  item  or a tuple  items .","id":"docstrings/DataAugmentation.apply.html"},{"body":"Overview DataAugmentation . jl makes it easy to create efficient, composable, stochastic data transformation pipelines .   Let ’ s unravel that . efficient : The most performant way of applying a transformation is selected based on the context composable : Transformations can be sequenced and combined in a sensible way stochastic : Parameters of the transformations can be random variables .  Care is taken to ensure that all transformations are target - preserving . The library also aims to be extensible and provides  interfaces  for implementing new transformations and custom kinds of data . In DataAugmentation . jl, you use transforms to transform  items  which represent your data .  This means you have to wrap your data in an  Item  type before applying transformations to it .  This might seem tedious but has some benefits: It resolves type ambiguities that arise because the same machine type can represent different data .  For example,  Array{Float, 3}  could represent an RGB image or a segmentation mask . Transformations can dispatch on the  Item  type . We can attach metadata to the data .","id":"docs/overview.html#overview"},{"body":"Examples","id":"docstrings/DataAugmentation.Keypoints.html#examples"},{"body":"public   apply!   —   function Applies  tfm  to  item , mutating the preallocated  buffer . buffer  can be obtained with  buffer = makebuffer(tfm, item) Default to  apply(tfm, item)  (non - mutating version) .","id":"docstrings/DataAugmentation.apply!.html"},{"body":"Examples","id":"docstrings/DataAugmentation.Polygon.html#examples"},{"body":"public   Image   —   parametric type Item representing an N - dimensional image with element type T . Supported  Transform s: all  AbstractAffine s","id":"docstrings/DataAugmentation.Image.html"},{"body":"public   Polygon   —   parametric type Item wrapper around  Keypoints .","id":"docstrings/DataAugmentation.Polygon.html"},{"body":"Example:","id":"docstrings/DataAugmentation.cropindices.html#example"},{"body":"CenterResizeCrop Resizes the sides so that one of them is no longer than  sz  and crops a region of size  sz   from the center .","id":"docs/imagetransforms.html#centerresizecrop"},{"body":"public   ScaleKeepAspect   —   struct Affine transformation that scales the shortest side of  item to  minlengths , keeping the original aspect ratio .","id":"docstrings/DataAugmentation.ScaleKeepAspect.html"},{"body":"DataAugmentation . jl Efficient, composable data augmentation for machine and deep learning .","id":"README.html#dataaugmentationjl"},{"body":"Spatial transformations DataAugmentation . jl comes with various spatial transformations that you can apply to your data .  You can apply them to  Image s and the keypoint - based items  Keypoints ,  Polygon , and  BoundingBox . Let ’ s take this picture of a light house: To apply a transformation  tfm  to it, wrap it in Image , apply the transformation and unwrap it using  itemdata : abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz Now let ’ s say we want to train a light house detector and have a bounding box for the light house .  We can use the  BoundingBox  item to represent it . It takes the two corners of the bounding rectangle as the first argument .  As the second argument we have to pass the size of the corresponding image . showitem  visualizes the two items: If we apply transformations like translation and cropping to the image, then the same transformations have to be applied to the bounding box .  Otherwise, the bounding box will no longer match up with the light house . Another problem can occur with stochastic transformations like  RandomResizeCrop . If we apply it separately to the image and the bounding box, they will be cropped from slightly different locations: Instead, pass a tuple of the items to a single  apply  call so the same random state will be used for both image and bounding box:","id":"docs/imagetransforms.html#spatial-transformations"},{"body":"Items Image Keypoints Polygon BoundingBox","id":"docs/items.html#items"},{"body":"private   AbstractArrayItem   —   parametric type Abstract type for all  [ Item ] s that wrap a  N - dimensional array with element type  T .","id":"docstrings/DataAugmentation.AbstractArrayItem.html"},{"body":"public   Transform   —   type Abstract supertype for all transformations .","id":"docstrings/DataAugmentation.Transform.html"},{"body":"public   CropDivisible   —   struct Does not remove any pixels, but pads width and height so they ’ re divisible by  factor","id":"docstrings/DataAugmentation.CropDivisible.html"},{"body":"public   getbounds   —   function","id":"docstrings/DataAugmentation.getbounds.html"},{"body":"public   Keypoints   —   parametric type N - dimensional keypoints represented as  SVector{N, T} . Spatial bounds are given by the polygon  bounds::Vector{SVector{N, T}} or  sz::NTuple{N, Int} .","id":"docstrings/DataAugmentation.Keypoints.html"},{"body":"Name Module Visibility Category  AbstractAffine   DataAugmentation   public   type   AbstractArrayItem   DataAugmentation   private   parametric type   BoundingBox   DataAugmentation   public   parametric type   ComposedAffine   DataAugmentation   private   struct   CropDivisible   DataAugmentation   public   struct   CroppedAffine   DataAugmentation   public   struct   Identity   DataAugmentation   public   struct   Image   DataAugmentation   public   parametric type   InplaceThreadsafe   DataAugmentation   private   struct   Keypoints   DataAugmentation   public   parametric type   MapElem   DataAugmentation   private   struct   Polygon   DataAugmentation   public   parametric type   ScaleKeepAspect   DataAugmentation   public   struct   Transform   DataAugmentation   public   type   apply!   DataAugmentation   public   function   apply   DataAugmentation   public   function   boundssize   DataAugmentation   private   function   cropindices   DataAugmentation   private   function   getaffine   DataAugmentation   private   function   getbounds   DataAugmentation   public   function   getrandstate   DataAugmentation   private   function   makebounds   DataAugmentation   private   function   makebuffer   DataAugmentation   public   function ","id":"docstrings.html#docstring-index"},{"body":"private   InplaceThreadsafe   —   struct","id":"docstrings/DataAugmentation.InplaceThreadsafe.html"},{"body":"private   cropindices   —   function","id":"docstrings/DataAugmentation.cropindices.html"},{"body":"public   AbstractAffine   —   type Abstract supertype for affine transformations .","id":"docstrings/DataAugmentation.AbstractAffine.html"},{"body":"Examples If  T  is not a color, the image will be interpreted as grayscale:","id":"docstrings/DataAugmentation.Image.html#examples"},{"body":"Crop (sz[, from]) Crops a region of size  sz  from the image,  without resizing  the image first .","id":"docs/imagetransforms.html#cropsz-from"},{"body":"private   makebounds   —   function Helper for creating spatial bounds .","id":"docstrings/DataAugmentation.makebounds.html"},{"body":"public   makebuffer   —   function Allocate a buffer .  Default to  buffer = apply(tfm, item) .","id":"docstrings/DataAugmentation.makebuffer.html"}]