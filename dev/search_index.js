var documenterSearchIndex = {"docs":
[{"location":"transforms/#Image-Transforms","page":"Image transforms","title":"Image Transforms","text":"","category":"section"},{"location":"transforms/","page":"Image transforms","title":"Image transforms","text":"pages = [\"transforms.md\"]","category":"page"},{"location":"transforms/","page":"Image transforms","title":"Image transforms","text":"using Images\nusing TestImages\nfunction showimagetransform(image, tfm)\n    imaget = apply(tfm, Image(image)).data\n\n    return mosaicview(image, imaget; nrow = 1, npad = 10, fillvalue = zero(RGBA))\nend","category":"page"},{"location":"transforms/","page":"Image transforms","title":"Image transforms","text":"using DataAugmentation\nusing Images: imresize\nusing TestImages\n\nimage = imresize(testimage(\"lighthouse\"); ratio = 1/2)","category":"page"},{"location":"transforms/#[FlipX](@ref)","page":"Image transforms","title":"FlipX","text":"","category":"section"},{"location":"transforms/","page":"Image transforms","title":"Image transforms","text":"tfm = FlipX()\nshowimagetransform(image, tfm) # hide","category":"page"},{"location":"transforms/#[FlipY](@ref)","page":"Image transforms","title":"FlipY","text":"","category":"section"},{"location":"transforms/","page":"Image transforms","title":"Image transforms","text":"tfm = FlipY()\nshowimagetransform(image, tfm) # hide","category":"page"},{"location":"quickstart/#quickstart","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"DataAugmentation.jl ","category":"page"},{"location":"quickstart/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"using TestImages\n\nimage = testimage(\"lighthouse\")\n\nitem = Image(image)\n\ntfm = RandomResizedCrop((128, 128)) |> FlipX()\n\n","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [DataAugmentation]","category":"page"},{"location":"reference/#DataAugmentation.AbstractAffine","page":"Reference","title":"DataAugmentation.AbstractAffine","text":"AbstractAffineTransform\n\nAbstract supertype for affine transformations\n\nSupporting custom AbstractAffineTransforms and Items\n\nAbstractAffineTransform interface\n\ngetaffine(t::MyAffineTransform, getbounds(item), getparam(t)) should return a transformation matrix (s. CoordinateTransformations.jl)\n\nItem interface\n\ngetbounds(item::MyItem)::Tuple returns the spatial bounds of an item, e.g. size(img) for an image array\napplyaffine(item::MyItem, A)::MyItem applies transformation matrix A (constructed with getaffine) to item and returns an item of the same type\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.Affine","page":"Reference","title":"DataAugmentation.Affine","text":"Affine\n\nApplies static transformation matrix tfm to an item\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.ComposedAffine","page":"Reference","title":"DataAugmentation.ComposedAffine","text":"ComposedAffine(transforms)\n\nComposes several affine transformations.\n\nDue to associativity of affine transformations, the transforms can be combined before applying, leading to large performance improvements.\n\ncomposeing multiple AbstractAffineTransformations automatically creates a ComposedAffine.\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.CroppedAffine","page":"Reference","title":"DataAugmentation.CroppedAffine","text":"CroppedAffine(transform, croptransform)\n\nApplies an affine transform and crops with croptransform, such that getbounds(t(item)) == getcrop(croptransform)\n\nThis wrapper leads to performance improvements when warping an image, since only the indices within the bounds of crop need to be evaluated.\n\ncomposeing any AbstractAffine with a CropTransform constructs a CroppedAffine.\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.Either","page":"Reference","title":"DataAugmentation.Either","text":"Either(transformations, probabilities)\n\nChooses one of transformations with probability in probabilities\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.Either-Tuple{Transform,Number}","page":"Reference","title":"DataAugmentation.Either","text":"Either(transform, p)\n\nApplies tfm with probability p\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataAugmentation.FlipX","page":"Reference","title":"DataAugmentation.FlipX","text":"FlipX()\n\nFlips an item along the x-axis\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.FlipY","page":"Reference","title":"DataAugmentation.FlipY","text":"FlipY()\n\nFlips an Item along the y-axis\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.Identity","page":"Reference","title":"DataAugmentation.Identity","text":"Identity()\n\nDoes not transform an item\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.Lambda","page":"Reference","title":"DataAugmentation.Lambda","text":"Lambda(f)\n\nApplies function f to an Item\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.Pipeline","page":"Reference","title":"DataAugmentation.Pipeline","text":"Pipeline\n\nA Pipeline combines several transformations and applies them sequentially\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.Rotate","page":"Reference","title":"DataAugmentation.Rotate","text":"RotateTransform(angle)\nRotateTransform(angles)\n\nRotates an Item by angle degrees counter-clockwise using an affine transformation. If a vector or range angles of degrees is given, picks one at random.\n\nSee also Rotate90, Rotate180, Rotate270 for more efficient non-affine versions for those specific angles.\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.Rotate180","page":"Reference","title":"DataAugmentation.Rotate180","text":"Rotate180()\n\nRotate clock-wise by 180 degress\n\nFaster than Rotate for array types.\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.Rotate270","page":"Reference","title":"DataAugmentation.Rotate270","text":"Rotate270()\n\nRotate clock-wise by 270 degress\n\nFaster than Rotate for array types.\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.Rotate90","page":"Reference","title":"DataAugmentation.Rotate90","text":"Rotate90()\n\nRotate clock-wise by 90 degress\n\nFaster than Rotate for array types.\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataAugmentation.Scale-Tuple{Tuple}","page":"Reference","title":"DataAugmentation.Scale","text":"Scale\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataAugmentation.apply-Tuple{Transform,Item}","page":"Reference","title":"DataAugmentation.apply","text":"apply(tfm, item)\napply(tfm, items)\n\nApply transform tfm to a single item or a tuple of items. If given a tuple, the same random state is used to transform the individual items.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataAugmentation.applyaffine","page":"Reference","title":"DataAugmentation.applyaffine","text":"applyaffine(item::Item, A, crop = nothing)\n\nApplies an affine transformation A to item, optionally cropping to tuple crop.\n\n\n\n\n\n","category":"function"},{"location":"reference/#DataAugmentation.applyaffine-Union{Tuple{C}, Tuple{Image{C},Any}, Tuple{Image{C},Any,Union{Nothing, Tuple}}} where C","page":"Reference","title":"DataAugmentation.applyaffine","text":"applyaffine(item, tfm, crop = nothing)\n\nApplies affine transformation matrix tfm to item, optionally cropping to window of size crop\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataAugmentation.applystep-Union{Tuple{N}, Tuple{Transform,Any,Tuple{Vararg{Symbol,N}}}} where N","page":"Reference","title":"DataAugmentation.applystep","text":"applystep(tfm, items, names)\n\nApplies tfm inplace to items in items given by keys names.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataAugmentation.compose-Tuple{Transform,Transform}","page":"Reference","title":"DataAugmentation.compose","text":"compose(tfm1, tfm2)\ntfm1 |> tfm2\n\nCombines two Transforms. The default behavior is to group them in a Pipeline that applies them sequentially.\n\nCustom methods can be used to implement performance improvements, for example merging two affine transformations.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataAugmentation.pickfromrange-Tuple{AbstractRange,AbstractFloat}","page":"Reference","title":"DataAugmentation.pickfromrange","text":"pickfromrange(rng::AbstractRange, rnd::AbstractFloat)\n\nGiven a number 0 <= rnd <= 1 that's generated by rand(), pick the element in range rng that is closest to it relative to rng's length\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DataAugmentation","category":"page"},{"location":"#DataAugmentation","page":"Home","title":"DataAugmentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"quickstart","category":"page"},{"location":"#Documentation-TODO","page":"Home","title":"Documentation TODO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Items\nComputer vision example^","category":"page"},{"location":"motivation/#Motivation","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"DataAugmentation.jl aims to make it easy to build stochastic label-preserving augmentation pipelines for your datasets.","category":"page"}]
}
